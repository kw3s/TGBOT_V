import logging
import os
import uuid
import shutil
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackContext

logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)

FFMPEG = "ffmpeg"

async def start(update: Update, context: CallbackContext):
    await update.message.reply_text("Send me an image + audio/voice. I'll merge into video.")

async def handle(update: Update, context: CallbackContext):
    user_id = update.effective_user.id
    dir = f"temp_{user_id}_{uuid.uuid4().hex[:8]}"
    os.makedirs(dir, exist_ok=True)

    image = None
    audio = None

    if update.message.photo:
        file = await update.message.photo[-1].get_file()
        image = os.path.join(dir, "image.jpg")
        await file.download_to_drive(image)

    if update.message.audio or update.message.voice or (update.message.document and update.message.document.mime_type and update.message.document.mime_type.startswith("audio")):
        obj = update.message.audio or update.message.voice or update.message.document
        file = await obj.get_file()
        ext = os.path.splitext(obj.file_name)[1] if obj.file_name else ".m4a"
        audio = os.path.join(dir, f"audio{ext}")
        await file.download_to_drive(audio)

    pending = context.user_data.setdefault("data", {})
    pending["image"] = pending.get("image") or image
    pending["audio"] = pending.get("audio") or audio
    pending["dir"] = dir

    if pending["image"] and pending["audio"]:
        out = os.path.join(dir, "video.mp4")
        cmd = f'{FFMPEG} -loop 1 -framerate 30 -i "{pending["image"]}" -i "{pending["audio"]}" -c:v libx264 -tune stillimage -c:a aac -b:a 192k -vf "scale=trunc(iw/2)*2:trunc(ih/2)*2,format=yuv420p" -shortest -y "{out}"'
        await update.message.reply_text("Processing...")
        os.system(cmd)
        try:
            await update.message.reply_video(open(out, "rb"), caption="Done!")
        except Exception as e:
            await update.message.reply_text(f"Error sending video: {str(e)}")
        finally:
            shutil.rmtree(dir)
            context.user_data.clear()
    else:
        await update.message.reply_text("Send the missing file (image or audio).")

def main():
    TOKEN = "8419784067:AAGMTG8M9QIzOBD56B_ROHe6a_VIHO6UpCM"
    app = Application.builder().token(TOKEN).write_timeout(60).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(MessageHandler(filters.PHOTO | filters.AUDIO | filters.VOICE | filters.Document.AUDIO, handle))

    print("Bot is running... Press Ctrl+C to stop")
    app.run_polling()

if name == 'main':
    main()

-------------------------------------------------
import logging, os, uuid, shutil, requests
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackContext

logging.basicConfig(level=logging.INFO)
FFMPEG = "ffmpeg"

async def start(update: Update, context: CallbackContext):
    await update.message.reply_text("Send album name → video with cover + audio")

async def handle_text(update: Update, context: CallbackContext):
    query = update.message.text.strip()
    dir = f"temp_{update.effective_user.id}_{uuid.uuid4().hex[:8]}"
    os.makedirs(dir, exist_ok=True)

    try:
        await update.message.reply_text("Searching Deezer...")
        r = requests.get(f"https://api.deezer.com/search/album?q={requests.utils.quote(query)}&limit=1", timeout=10).json()
        if not r.get("data"): raise Exception("Not found")
        album = r["data"][0]
        cover = album["cover_big"]
        artist = album["artist"]["name"]
        title = album["title"]

        img = f"{dir}/cover.jpg"
        requests.get(cover, timeout=15).raise_for_status()
        open(img, "wb").write(requests.get(cover).content)

        audio = f"{dir}/audio.m4a"
        await update.message.reply_text("Downloading audio...")
        os.system(f'yt-dlp -x --audio-format m4a -o "{audio}" "ytsearch1:{artist} {title} full album" --quiet')

        if not os.path.exists(audio): raise Exception("Audio failed")

        out = f"{dir}/video.mp4"
        await update.message.reply_text("Creating video...")
        os.system(f'{FFMPEG} -loop 1 -i "{img}" -i "{audio}" -c:v libx264 -tune stillimage -c:a aac -b:a 192k -vf "scale=trunc(iw/2)*2:trunc(ih/2)*2,format=yuv420p" -shortest -y "{out}" -loglevel error')

        if not os.path.exists(out): raise Exception("FFmpeg failed")

        await update.message.reply_video(open(out, "rb"), caption=f"{artist} – {title}")

    except Exception as e:
        await update.message.reply_text(f"Error: {e}")
    finally:
        shutil.rmtree(dir, ignore_errors=True)

def main():
    app = Application.builder().token("8419784067:AAGMTG8M9QIzOBD56B_ROHe6a_VIHO6UpCM").write_timeout(180).build()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_text))
    app.run_polling()

if name == "main":
    main()

-------------------------------------------------
import logging
import os
import uuid
import shutil
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackContext

logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)

FFMPEG = "ffmpeg"

async def start(update: Update, context: CallbackContext):
    await update.message.reply_text("Send me an image + audio/voice. I'll merge into video.")

async def handle(update: Update, context: CallbackContext):
    user_id = update.effective_user.id
    dir = f"temp_{user_id}_{uuid.uuid4().hex[:8]}"
    os.makedirs(dir, exist_ok=True)

    image = None
    audio = None

    if update.message.photo:
        file = await update.message.photo[-1].get_file()
        image = os.path.join(dir, "image.jpg")
        await file.download_to_drive(image)

    if update.message.audio or update.message.voice or (update.message.document and update.message.document.mime_type and update.message.document.mime_type.startswith("audio")):
        obj = update.message.audio or update.message.voice or update.message.document
        file = await obj.get_file()
        ext = os.path.splitext(obj.file_name)[1] if obj.file_name else ".m4a"
        audio = os.path.join(dir, f"audio{ext}")
        await file.download_to_drive(audio)

    pending = context.user_data.setdefault("data", {})
    pending["image"] = pending.get("image") or image
    pending["audio"] = pending.get("audio") or audio
    pending["dir"] = dir

    if pending["image"] and pending["audio"]:
        out = os.path.join(dir, "video.mp4")
        cmd = f'{FFMPEG} -loop 1 -framerate 30 -i "{pending["image"]}" -i "{pending["audio"]}" -c:v libx264 -tune stillimage -c:a aac -b:a 192k -vf "scale=trunc(iw/2)*2:trunc(ih/2)*2,format=yuv420p" -shortest -y "{out}"'
        await update.message.reply_text("Processing...")
        os.system(cmd)
        await update.message.reply_video(open(out, "rb"), caption="Done!")
        shutil.rmtree(dir)
        context.user_data.clear()
    else:
        await update.message.reply_text("Send the missing file (image or audio).")

def main():
    TOKEN = "8419784067:AAGMTG8M9QIzOBD56B_ROHe6a_VIHO6UpCM"
    app = Application.builder().token(TOKEN).write_timeout(60).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(MessageHandler(filters.PHOTO | filters.AUDIO | filters.VOICE | filters.Document.AUDIO, handle))

    print("Bot is running... Press Ctrl+C to stop")
    app.run_polling()

if name == 'main':
    main()
-------------------------------------------------

import logging
import os
import uuid
import shutil
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, CallbackContext

logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)

FFMPEG = "ffmpeg"

async def start(update: Update, context: CallbackContext):
    await update.message.reply_text("Send me an image + audio/voice. I'll merge into video.")

async def handle(update: Update, context: CallbackContext):
    user_id = update.effective_user.id
    dir = f"temp_{user_id}_{uuid.uuid4().hex[:8]}"
    os.makedirs(dir, exist_ok=True)

    image = None
    audio = None

    if update.message.photo:
        file = await update.message.photo[-1].get_file()
        image = os.path.join(dir, "image.jpg")
        await file.download_to_drive(image)

    if update.message.audio or update.message.voice or (update.message.document and update.message.document.mime_type and update.message.document.mime_type.startswith("audio")):
        obj = update.message.audio or update.message.voice or update.message.document
        file = await obj.get_file()
        ext = os.path.splitext(obj.file_name)[1] if obj.file_name else ".m4a"
        audio = os.path.join(dir, f"audio{ext}")
        await file.download_to_drive(audio)

    pending = context.user_data.setdefault("data", {})
    pending["image"] = pending.get("image") or image
    pending["audio"] = pending.get("audio") or audio
    pending["dir"] = dir

    if pending["image"] and pending["audio"]:
        out = os.path.join(dir, "video.mp4")
        cmd = f'{FFMPEG} -loop 1 -i "{pending["image"]}" -i "{pending["audio"]}" -c:v libx264 -tune stillimage -c:a aac -b:a 192k -pix_fmt yuv420p -shortest -y "{out}"'
        await update.message.reply_text("Processing...")
        os.system(cmd)
        await update.message.reply_video(open(out, "rb"), caption="Done!")
        shutil.rmtree(dir)
        context.user_data.clear()
    else:
        await update.message.reply_text("Send the missing file (image or audio).")

def main():
    TOKEN = "8419784067:AAGMTG8M9QIzOBD56B_ROHe6a_VIHO6UpCM"
    app = Application.builder().token(TOKEN).build()

    app.add_handler(CommandHandler("start", start))
    app.add_handler(MessageHandler(filters.PHOTO | filters.AUDIO | filters.VOICE | filters.Document.AUDIO, handle))

    print("Bot is running... Press Ctrl+C to stop")
    app.run_polling()

if name == 'main':
    main()