const { mergeAudioImage } = require('./ffmpegUtils');
const fs = require('fs');
const path = require('path');
const axios = require('axios');
const os = require('os');

// Helper to download file
async function downloadFile(url, filepath) {
    const writer = fs.createWriteStream(filepath);
    const response = await axios({
        url,
        method: 'GET',
        responseType: 'stream'
    });
    response.data.pipe(writer);
    return new Promise((resolve, reject) => {
        writer.on('finish', resolve);
        writer.on('error', reject);
    });
}

async function handleManualMode(bot, msg) {
    const chatId = msg.chat.id;

    // Check if this is a reply to a bot message OR if we have state
    const { getUserImage, clearUserImage } = require('./state');
    const cachedImageId = getUserImage(chatId);

    if ((msg.reply_to_message && msg.reply_to_message.from.is_bot) || cachedImageId) {
        const replyText = msg.reply_to_message ? msg.reply_to_message.text : "";

        // Scenario: User sent Audio (Reply OR State)
        if (msg.audio) {
            // Determine Image ID
            let imageFileId = null;

            if (replyText.includes("Got image")) {
                const match = replyText.match(/ID: ([\w-]+)/);
                if (match) imageFileId = match[1];
            } else if (cachedImageId) {
                imageFileId = cachedImageId;
            }

            if (imageFileId) {
                const audioFileId = msg.audio.file_id;

                // LOCK MECHANISM: Check if we are already processing this audio
                const tmpDir = os.tmpdir();
                const lockFile = path.join(tmpDir, `lock_${audioFileId}.lock`);

                if (fs.existsSync(lockFile)) {
                    console.log(`Duplicate request detected for audio ${audioFileId}. Ignoring.`);
                    return; // Silently ignore duplicate requests
                }

                // Create Lock
                fs.writeFileSync(lockFile, 'processing');

                await bot.sendMessage(chatId, "Processing your media... ‚è≥\n1. Downloading files...");

                try {
                    // 1. Get File Links
                    const imageLink = await bot.getFileLink(imageFileId);
                    const audioLink = await bot.getFileLink(audioFileId);

                    // 2. Download Files to /tmp
                    const audioTitle = msg.audio.title || msg.audio.file_name || 'video';
                    const sanitizedTitle = audioTitle.replace(/[<>:"/\|?*]/g, '').substring(0, 100);
                    const imagePath = path.join(tmpDir, `${imageFileId}.jpg`);
                    const audioPath = path.join(tmpDir, `${audioFileId}.mp3`);
                    const outputPath = path.join(tmpDir, `${sanitizedTitle}.mp4`);

                    await downloadFile(imageLink, imagePath);
                    await downloadFile(audioLink, audioPath);

                    const { startAnimation } = require('./animation');

                    const processingMsg = await bot.sendMessage(chatId, "Merging files... üé¨");
                    const stopAnimation = await startAnimation(bot, chatId, processingMsg.message_id, "Merging files...");

                    // 3. Merge
                    await mergeAudioImage(imagePath, audioPath, outputPath);

                    stopAnimation();

                    // 4. Send Video
                    await bot.sendMessage(chatId, "3. Uploading video... üöÄ");
                    await bot.sendVideo(chatId, fs.createReadStream(outputPath), {
                        caption: "Here is your video! üé•\nGenerated by VidGen5"
                    });

                    // 5. Cleanup
                    fs.unlinkSync(imagePath);
                    fs.unlinkSync(audioPath);
                    fs.unlinkSync(outputPath);
                    // Remove Lock
                    if (fs.existsSync(lockFile)) fs.unlinkSync(lockFile);

                    // Clear State
                    clearUserImage(chatId);

                } catch (error) {
                    console.error("Error in Manual Mode:", error);
                    await bot.sendMessage(chatId, `‚ùå Error: ${error.message}`);
                    // Remove Lock on Error
                    if (fs.existsSync(lockFile)) fs.unlinkSync(lockFile);
                }
                return;
            }
        }
    }

    const { setUserImage } = require('./state');

    // ... (inside handleManualMode)

    // Scenario: User sent an Image
    if (msg.photo) {
        const fileId = msg.photo[msg.photo.length - 1].file_id; // Get largest size

        // Save to State (Best Effort for Forwarding)
        setUserImage(chatId, fileId);

        // Reply with the fileID hidden or visible so we can reference it later
        await bot.sendMessage(chatId, `Got image! (ID: ${fileId})\nNow reply to THIS message with your Audio file.\n\nüí° Missing audio?\nSend a Spotify, Deezer, Tidal or Apple Music link to @MUSICSHUNTERSBOT and forward the resulting audio back here!`, {
            reply_to_message_id: msg.message_id,
            reply_markup: { force_reply: true }
        });
        return;
    }

    // Default: Instructions
    await bot.sendMessage(chatId, "üì∏ Manual Mode\n\n1. Send me an Image first.\n2. Then reply to that image with your Audio file.\n\nüí° Missing audio?\nSend a Spotify, Deezer, Tidal or Apple Music link to @MUSICSHUNTERSBOT and forward the resulting audio back here!");
}

module.exports = { handleManualMode };
