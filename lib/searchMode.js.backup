import logging, os, uuid, shutil, requests, asyncio, time, subprocess, json, sys
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ContextTypes
from concurrent.futures import ThreadPoolExecutor
import threading

# ‚ö†Ô∏è SECURITY WARNING: Never commit this file to public repositories or share it
BOT_TOKEN = "8419784067:AAGMTG8M9QIzOBD56B_ROHe6a_VIHO6UpCM"

# Configure logging - minimal for Termux
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    datefmt='%H:%M:%S'
)
logger = logging.getLogger(__name__)

# Performance settings for Termux - ultra compatible
FFMPEG = "ffmpeg"
MAX_FILE_SIZE = 12 * 1024 * 1024  # 12MB for reliability
MAX_VIDEO_SIZE = 40 * 1024 * 1024  # 40MB for safety
WRITE_TIMEOUT = 600  # 10 minutes for all operations
MAX_WORKERS = 1  # Single worker for Termux stability

# Mode constants
MODE_SEARCH = "search"
MODE_MANUAL = "manual"
MODE_AUDIO_ONLY = "audio_only"
MODE_AUDIO_ONLY_DETAILS = "audio_only_details"

# Thread pool for async operations
executor = ThreadPoolExecutor(max_workers=MAX_WORKERS)

# Global cleanup thread
cleanup_active = True
cleanup_thread = None

def cleanup_worker():
    """Background thread for cleanup to avoid interfering with main operations"""
    while cleanup_active:
        try:
            # Clean old temp directories (older than 5 minutes)
            current_time = time.time()
            for item in os.listdir():
                if item.startswith('temp_') and os.path.isdir(item):
                    try:
                        item_time = os.path.getmtime(item)
                        if current_time - item_time > 300:  # 5 minutes
                            shutil.rmtree(item, ignore_errors=True)
                            logger.info(f"üßπ Background cleaned: {item}")
                    except Exception as e:
                        logger.warning(f"üßπ Cleanup warning: {e}")
            time.sleep(60)  # Check every minute
        except Exception as e:
            logger.error(f"üßπ Cleanup thread error: {e}")
            time.sleep(30)

async def run_async(func, *args, **kwargs):
    """Run blocking function in thread pool with proper error handling"""
    try:
        loop = asyncio.get_running_loop()
        return await asyncio.wait_for(
            loop.run_in_executor(executor, lambda: func(*args, **kwargs)),
            timeout=300  # 5 minutes max per operation
        )
    except asyncio.TimeoutError:
        logger.error(f"‚è∞ Operation timed out: {func.__name__}")
        raise Exception("Operation timed out. Please try again with smaller files.")
    except Exception as e:
        logger.error(f"‚ö° Async error: {e}")
        raise

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Welcome message with mode selection"""
    await show_mode_selection(update, context, "üé¨ Welcome to Video Generator Bot!\nChoose a mode to start:")

async def modes(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Command to return to mode selection"""
    if context.user_data.get("processing"):
        await update.message.reply_text("‚è≥ Please wait for current operation to finish...")
        return
        
    if context.user_data.get("temp_dir"):
        await cleanup_temp_dir(context, force=True)
    
    await show_mode_selection(update, context, "üîÑ Select mode:")

async def show_mode_selection(update: Update, context: ContextTypes.DEFAULT_TYPE, message_text: str):
    """Helper function to show mode selection keyboard"""
    keyboard = [
        [InlineKeyboardButton("üéµ 1. Song/Album Search", callback_data=MODE_SEARCH)],
        [InlineKeyboardButton("üñºÔ∏è 2. Send Image + Audio", callback_data=MODE_MANUAL)],
        [InlineKeyboardButton("üéß 3. Send Audio ‚Üí Auto Cover", callback_data=MODE_AUDIO_ONLY)],
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    if update.message:
        await update.message.reply_text(message_text, reply_markup=reply_markup)
    else:
        await update.callback_query.edit_message_text(message_text, reply_markup=reply_markup)

async def button(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle mode selection buttons"""
    query = update.callback_query
    await query.answer()
    
    # Set mode and initialize temp storage
    mode = query.data
    context.user_data["mode"] = mode
    context.user_data["pending"] = {}
    context.user_data["processing"] = False
    
    # Create temp directory for this session
    temp_dir = f"temp_{update.effective_user.id}_{uuid.uuid4().hex[:6]}"
    try:
        os.makedirs(temp_dir, exist_ok=True)
        context.user_data["temp_dir"] = temp_dir
    except Exception as e:
        logger.error(f"Temp dir creation failed: {e}")
        await query.edit_message_text("‚ùå Failed to create temporary storage. Please try again.")
        return

    if mode == MODE_SEARCH:
        await query.edit_message_text("üéµ Mode: Song/Album Search\nSend album or song name (e.g., 'Thriller Michael Jackson').")
    elif mode == MODE_MANUAL:
        await query.edit_message_text("üñºÔ∏è Mode: Manual\nSend image + audio (any order). I'll wait for both files.")
    elif mode == MODE_AUDIO_ONLY:
        await query.edit_message_text("üéß Mode: Audio Only\nSend audio file first ‚Üí Then I'll ask for track details.")

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Cancel current operation and return to mode selection"""
    context.user_data["processing"] = False  # Stop any ongoing processing
    if context.user_data.get("temp_dir"):
        await cleanup_temp_dir(context, force=True)
    await update.message.reply_text("‚ùå Operation cancelled. Use /modes to select a new mode.")

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Main message handler for all modes"""
    if context.user_data.get("processing"):
        await update.message.reply_text("‚è≥ Please wait for current operation to finish...")
        return

    mode = context.user_data.get("mode")
    if not mode:
        await update.message.reply_text("Please select a mode first using /start or /modes")
        return

    # Basic rate limiting
    last_msg = context.user_data.get("last_message_time", 0)
    if time.time() - last_msg < 1.0:  # 1 second cooldown
        return
    context.user_data["last_message_time"] = time.time()

    temp_dir = context.user_data.get("temp_dir")
    if not temp_dir or not os.path.exists(temp_dir):
        temp_dir = f"temp_{update.effective_user.id}_{uuid.uuid4().hex[:6]}"
        os.makedirs(temp_dir, exist_ok=True)
        context.user_data["temp_dir"] = temp_dir
        context.user_data["pending"] = {}

    pending = context.user_data.setdefault("pending", {})

    # Handle text input
    if update.message.text and not (update.message.photo or update.message.audio or update.message.document or update.message.voice):
        if mode == MODE_SEARCH:
            context.user_data["processing"] = True
            try:
                await do_search(update, context)
            finally:
                context.user_data["processing"] = False
            return
        elif mode == MODE_AUDIO_ONLY_DETAILS:
            pending["track_details"] = update.message.text.strip()
            context.user_data["processing"] = True
            try:
                await do_audio_only(update, context, pending)
            finally:
                context.user_data["processing"] = False
            return

    # Handle file uploads
    await process_files(update, context, pending, temp_dir)

async def process_files(update: Update, context: ContextTypes.DEFAULT_TYPE, pending: dict, temp_dir: str):
    """Process incoming files efficiently"""
    # Process image
    if update.message.photo:
        if update.message.photo[-1].file_size > MAX_FILE_SIZE:
            await update.message.reply_text(f"‚ùå Image too large! Max size: {MAX_FILE_SIZE // (1024*1024)}MB")
            return
            
        context.user_data["processing"] = True
        try:
            file = await update.message.photo[-1].get_file()
            image_path = os.path.join(temp_dir, "image.jpg")
            await file.download_to_drive(image_path)
            pending["image"] = image_path
            await update.message.reply_text("‚úÖ Image received!")
        finally:
            context.user_data["processing"] = False

    # Process audio
    audio_obj = None
    if update.message.audio:
        audio_obj = update.message.audio
    elif update.message.voice:
        audio_obj = update.message.voice
    elif update.message.document and update.message.document.mime_type and "audio" in update.message.document.mime_type:
        audio_obj = update.message.document

    if audio_obj:
        if audio_obj.file_size > MAX_FILE_SIZE:
            await update.message.reply_text(f"‚ùå Audio too large! Max size: {MAX_FILE_SIZE // (1024*1024)}MB")
            return
            
        context.user_data["processing"] = True
        try:
            file = await audio_obj.get_file()
            ext = ".m4a" if update.message.voice else os.path.splitext(audio_obj.file_name or "")[1] or ".m4a"
            audio_path = os.path.join(temp_dir, f"audio{ext}")
            await file.download_to_drive(audio_path)
            pending["audio"] = audio_path
            pending["title"] = audio_obj.title or audio_obj.file_name or "Unknown Track"
            
            mode = context.user_data.get("mode")
            if mode == MODE_AUDIO_ONLY:
                context.user_data["mode"] = MODE_AUDIO_ONLY_DETAILS
                await update.message.reply_text(
                    f"üéß Now tell me the exact track name and artist for:\n"
                    f"**{pending['title']}**\n\n"
                    f"Example: 'Blinding Lights The Weeknd'"
                )
                return
            elif mode == MODE_MANUAL and pending.get("image"):
                await merge_and_send(update, context, pending)
        finally:
            context.user_data["processing"] = False

async def do_search(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Search for album/song and create video - ultra stable"""
    query = update.message.text.strip()
    temp_dir = context.user_data["temp_dir"]
    pending = context.user_data["pending"]
    
    try:
        status_msg = await update.message.reply_text("üîç Searching Deezer...")
        
        # Search Deezer API
        search_url = f"https://api.deezer.com/search/album?q={requests.utils.quote(query)}&limit=1"
        response = await run_async(requests.get, search_url, timeout=15)
        response.raise_for_status()
        data = response.json()
        
        if not data.get("data"):
            raise Exception("No results found on Deezer. Try different keywords.")
            
        album = data["data"][0]
        cover_url = album["cover_big"]
        artist = album["artist"]["name"]
        title = album["title"]
        
        await status_msg.edit_text(f"‚úÖ Found: {artist} - {title}\n‚¨áÔ∏è Downloading cover...")
        
        # Download cover art
        cover_path = os.path.join(temp_dir, "cover.jpg")
        cover_data = await run_async(requests.get, cover_url, timeout=15)
        cover_data.raise_for_status()
        with open(cover_path, "wb") as f:
            f.write(cover_data.content)
        pending["image"] = cover_path
        
        await status_msg.edit_text(f"‚úÖ Cover downloaded\n‚¨áÔ∏è Downloading audio...")
        
        # Download audio
        audio_path = os.path.join(temp_dir, "audio.m4a")
        search_query = f"{artist} {title} audio"
        
        cmd = [
            'yt-dlp', '-x', '--audio-format', 'm4a',
            '-o', audio_path,
            f'ytsearch1:{search_query}',
            '--quiet', '--no-warnings',
            '--max-filesize', '12M',
            '--extract-audio'
        ]
        
        result = await run_async(subprocess_run_with_timeout, cmd, 120)
        if result.returncode != 0 or not os.path.exists(audio_path):
            error_msg = result.stderr.strip() if hasattr(result, 'stderr') else "Download failed"
            raise Exception(f"Audio download failed: {error_msg[:100]}")
            
        pending["audio"] = audio_path
        pending["caption"] = f"üéµ {artist} - {title}"
        
        await status_msg.edit_text("‚úÖ Audio downloaded\nüé¨ Creating video...")
        await merge_and_send(update, context, pending, status_msg)

    except Exception as e:
        logger.error(f"Search failed: {e}")
        await update.message.reply_text(f"‚ùå Search error: {str(e)}")
        await cleanup_temp_dir(context, force=True)

async def do_audio_only(update: Update, context: ContextTypes.DEFAULT_TYPE, pending: dict):
    """Fetch cover art for audio-only mode"""
    temp_dir = context.user_data["temp_dir"]
    track_details = pending.get("track_details", pending.get("title", "Unknown Track"))
    
    try:
        status_msg = await update.message.reply_text(f"üîç Searching for: '{track_details}'...")
        
        clean_query = track_details.strip()
        search_url = f"https://api.deezer.com/search?q={requests.utils.quote(clean_query)}&limit=2"
        response = await run_async(requests.get, search_url, timeout=15)
        response.raise_for_status()
        data = response.json()
        
        if not data.get("data"):
            raise Exception(f"No results for '{track_details}'")
        
        track = data["data"][0]
        cover_url = track["album"]["cover_big"]
        artist = track["artist"]["name"]
        song_title = track["title"]
        
        await status_msg.edit_text(f"‚úÖ Found: {artist} - {song_title}\n‚¨áÔ∏è Downloading cover...")
        
        cover_path = os.path.join(temp_dir, "cover.jpg")
        cover_data = await run_async(requests.get, cover_url, timeout=15)
        cover_data.raise_for_status()
        with open(cover_path, "wb") as f:
            f.write(cover_data.content)
        pending["image"] = cover_path
        pending["caption"] = f"üéµ {artist} - {song_title}"
        
        await merge_and_send(update, context, pending, status_msg)

    except Exception as e:
        logger.error(f"Cover fetch failed: {e}")
        default_img_path = os.path.join(temp_dir, "default.jpg")
        cmd = [
            FFMPEG, '-f', 'lavfi', '-i', 'color=c=black:s=480x480',
            '-vf', "drawtext=text='No Cover':fontcolor=white:fontsize=24:x=(w-text_w)/2:y=(h-text_h)/2",
            '-vframes', '1', '-y', default_img_path
        ]
        await run_async(subprocess_run_with_timeout, cmd, 15)
        pending["image"] = default_img_path
        pending["caption"] = f"üéµ {pending.get('title', 'Unknown')}"
        await status_msg.edit_text("‚ö†Ô∏è Using default cover\nüé¨ Creating video...")
        await merge_and_send(update, context, pending, status_msg)

async def merge_and_send(update: Update, context: ContextTypes.DEFAULT_TYPE, pending: dict, status_msg=None):
    """Merge image and audio into video - ultra stable version"""
    temp_dir = context.user_data["temp_dir"]
    output_path = os.path.join(temp_dir, "video.mp4")
    caption = pending.get("caption", "üéµ Video ready!")
    
    try:
        if not status_msg:
            status_msg = await update.message.reply_text("üé¨ Creating video...")
        
        # Optimized ffmpeg command for Termux stability
        cmd = [
            FFMPEG,
            '-loop', '1',
            '-i', pending["image"],
            '-i', pending["audio"],
            '-c:v', 'libx264',
            '-tune', 'stillimage',
            '-c:a', 'aac',
            '-b:a', '128k',
            '-vf', 'scale=480:trunc(480*ih/iw),format=yuv420p',  # Fixed aspect ratio
            '-shortest',
            '-movflags', '+faststart',
            '-y',
            output_path,
            '-loglevel', 'error'
        ]
        
        logger.info(f"üé¨ Running ffmpeg: {' '.join(cmd)}")
        start_time = time.time()
        result = await run_async(subprocess_run_with_timeout, cmd, 180)  # 3 minutes max
        elapsed_time = time.time() - start_time
        
        if result.returncode != 0 or not os.path.exists(output_path):
            error_msg = result.stderr.strip() if hasattr(result, 'stderr') else "Video creation failed"
            logger.error(f"üé¨ FFmpeg failed: {error_msg}")
            raise Exception(f"Video creation failed: {error_msg[:150]}")
        
        video_size = os.path.getsize(output_path)
        size_mb = video_size / (1024 * 1024)
        logger.info(f"‚úÖ Video created: {size_mb:.1f}MB in {elapsed_time:.1f}s")
        
        if video_size > MAX_VIDEO_SIZE:
            await status_msg.edit_text(f"‚ùå Video too large ({size_mb:.1f}MB). Maximum: 40MB")
            return
        
        await status_msg.edit_text(f"‚úÖ Video ready ({size_mb:.1f}MB)\nüì§ Sending to Telegram...")
        
        # SINGLE send attempt - no retries to prevent duplicates
        try:
            with open(output_path, 'rb') as video_file:
                # Use a separate message for the video to avoid edit conflicts
                video_msg = await update.message.reply_video(
                    video_file,
                    caption=caption,
                    # Timeout settings compatible with older versions
                )
            await status_msg.edit_text("üéâ **Perfect!** Your video is ready!\n\nüîÑ Use /modes for another video")
            logger.info("‚úÖ Video successfully delivered")
        except Exception as e:
            logger.error(f"üì§ Send failed: {e}")
            # Try document fallback ONCE
            try:
                with open(output_path, 'rb') as video_file:
                    doc_msg = await update.message.reply_document(
                        video_file,
                        filename="video.mp4",
                        caption=f"üìÅ Large video file (Telegram preview limit)\n{caption}",
                    )
                await status_msg.edit_text("‚úÖ **Sent as file** (large video)")
                logger.info("‚úÖ Video sent as document")
            except Exception as e2:
                logger.error(f"üìÅ Document fallback failed: {e2}")
                await status_msg.edit_text(
                    f"‚ùå **Delivery failed** but video was created!\n"
                    f"üì± **In Termux:** Use file manager to find:\n"
                    f"`{output_path}`\n\n"
                    f"üîÑ Use /cancel and try again with smaller files",
                    parse_mode='Markdown'
                )
                # Don't clean up immediately - let user access the file
                context.user_data["cleanup_delayed"] = True
                return

        # Success - clean up after delay to ensure Telegram processes everything
        await asyncio.sleep(3)  # Wait 3 seconds before cleanup
        await cleanup_temp_dir(context, force=True)

    except Exception as e:
        logger.error(f"üé¨ Video processing failed: {e}")
        await update.message.reply_text(f"‚ùå Processing error: {str(e)}")
        await cleanup_temp_dir(context, force=True)

def subprocess_run_with_timeout(cmd, timeout):
    """Run subprocess with robust timeout handling"""
    try:
        logger.debug(f"üèÉ Running: {' '.join(cmd)}")
        return subprocess.run(cmd, capture_output=True, text=True, timeout=timeout)
    except subprocess.TimeoutExpired as e:
        logger.error(f"‚è∞ Timeout expired after {timeout}s: {cmd[0]}")
        return type('Result', (), {'returncode': 1, 'stderr': f'Timed out after {timeout} seconds'})()
    except Exception as e:
        logger.error(f"‚ö° Subprocess error: {e}")
        return type('Result', (), {'returncode': 1, 'stderr': str(e)})()

async def cleanup_temp_dir(context: ContextTypes.DEFAULT_TYPE, force=False):
    """Clean up temporary directory - safe version"""
    if context.user_data.get("cleanup_delayed") and not force:
        return
        
    temp_dir = context.user_data.get("temp_dir")
    if temp_dir and os.path.exists(temp_dir):
        try:
            # Wait a bit before cleanup to ensure all file handles are released
            await asyncio.sleep(1)
            shutil.rmtree(temp_dir, ignore_errors=True)
            logger.info(f"üßπ Cleaned up: {temp_dir}")
        except Exception as e:
            logger.warning(f"üßπ Cleanup warning: {e}")
            # Try again after longer delay
            await asyncio.sleep(3)
            shutil.rmtree(temp_dir, ignore_errors=True)
    
    context.user_data.clear()

async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Send help message"""
    help_text = """
üé¨ **Video Generator Bot - Termux Edition**

**Commands:**
/start - Start the bot
/modes - Change mode anytime
/cancel - Cancel current operation
/help - Show this help

**Modes:**
üéµ **Song Search**: Type any song/album name
üñºÔ∏è **Manual Mode**: Send image + audio files
üéß **Audio Only**: Send audio, then provide track name + artist

**Termux Optimized:**
‚Ä¢ ‚úÖ Max file size: 12MB (more reliable)
‚Ä¢ ‚úÖ 10-minute timeouts for slow networks
‚Ä¢ ‚úÖ No duplicate videos
‚Ä¢ ‚úÖ Automatic cleanup
‚Ä¢ ‚úÖ Single send attempt to prevent duplicates
‚Ä¢ ‚úÖ Background cleanup for old files

**Tips for Best Results:**
‚Ä¢ Keep audio clips under 2 minutes
‚Ä¢ Use simple search terms (artist + song name)
‚Ä¢ If video fails to send, check your file manager for the video file
‚Ä¢ Use /cancel if bot seems stuck
‚Ä¢ Restart bot with /start if needed

‚ú® **New:** Ultra-stable sending with no timeout errors after delivery!
    """
    await update.message.reply_text(help_text, parse_mode='Markdown')

def check_dependencies():
    """Check required dependencies"""
    missing = []
    if not shutil.which(FFMPEG):
        missing.append(f"{FFMPEG} (pkg install ffmpeg)")
    if not shutil.which('yt-dlp'):
        missing.append("yt-dlp (pip install yt-dlp)")
    return missing

def start_cleanup_thread():
    """Start background cleanup thread"""
    global cleanup_thread, cleanup_active
    cleanup_active = True
    cleanup_thread = threading.Thread(target=cleanup_worker, daemon=True)
    cleanup_thread.start()
    logger.info("üßπ Background cleanup thread started")

def stop_cleanup_thread():
    """Stop background cleanup thread"""
    global cleanup_active
    cleanup_active = False
    if cleanup_thread and cleanup_thread.is_alive():
        cleanup_thread.join(timeout=2.0)
    logger.info("üßπ Background cleanup stopped")

def get_library_version():
    """Get python-telegram-bot version for compatibility"""
    try:
        import telegram
        return telegram.__version__
    except:
        return "unknown"

def main():
    """Main function - fully compatible with older library versions"""
    # Start background cleanup
    start_cleanup_thread()
    
    # Dependency check
    missing = check_dependencies()
    if missing:
        print("‚ùå Missing dependencies:", ", ".join(missing))
        print("üì± Termux installation commands:")
        print("pkg update && pkg install python ffmpeg")
        print("pip install python-telegram-bot requests yt-dlp")
        stop_cleanup_thread()
        sys.exit(1)
    
    # Clean old temp files
    for item in os.listdir():
        if item.startswith('temp_') and os.path.isdir(item):
            try:
                if time.time() - os.path.getmtime(item) > 600:  # 10 minutes old
                    shutil.rmtree(item, ignore_errors=True)
                    logger.info(f"üßπ Startup cleaned: {item}")
            except:
                pass
    
    # Get library version for debugging
    lib_version = get_library_version()
    print(f"‚úÖ Bot starting... (compatible mode)")
    print(f"üì± Termux optimized - library version: {lib_version}")
    print("üîÑ Use /modes to switch modes anytime")
    print("‚è±Ô∏è  Using 10-minute timeouts for reliability")
    
    # Build application - compatible with older versions
    try:
        app = Application.builder().token(BOT_TOKEN).build()
    except Exception as e:
        print(f"‚ùå Failed to build application: {e}")
        print("üì± Try updating the library: pip install --upgrade python-telegram-bot")
        stop_cleanup_thread()
        sys.exit(1)
    
    # Register handlers
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("modes", modes))
    app.add_handler(CommandHandler("cancel", cancel))
    app.add_handler(CommandHandler("help", help_command))
    app.add_handler(CallbackQueryHandler(button))
    app.add_handler(MessageHandler(filters.ALL & ~filters.COMMAND, handle_message))
    
    try:
        # Run polling - compatible with older versions
        app.run_polling()
    except KeyboardInterrupt:
        print("\nüõë Bot stopped by user")
    except Exception as e:
        print(f"‚ùå Bot crashed: {e}")
        print(f"üì± Library version: {lib_version}")
        print("üîç Common fixes:")
        print("- pip install --upgrade python-telegram-bot")
        print("- pkg install ffmpeg")
        print("- Check if bot token is correct")
    finally:
        stop_cleanup_thread()
        # Final cleanup
        for item in os.listdir():
            if item.startswith('temp_') and os.path.isdir(item):
                shutil.rmtree(item, ignore_errors=True)

if __name__ == "__main__":
    main()